# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Document Protection Rules

This project has a structured documentation system with protection rules:

### Category 1: Core Project Documents (AI Modification Prohibited)
- **Location**: Root directory
- **Files**: README.md, TECH_STACK.md, FEATURES.md, USAGE.md, CHANGELOG.md, SECURITY.md, LICENSE, CLAUDE.md
- **Protection**: Headers with `<!-- 🚫 AI_MODIFY_PROHIBITED -->`
- **Rule**: These files should NOT be modified by AI agents

### Category 2: Auto-generated API Documentation
- **Location**: /api-docs/
- **Protection**: Directory-level protection in .claudeignore
- **Rule**: No manual modifications allowed - generated by tools only

### Category 3: Core Design Specifications (AI Modification Prohibited)
- **Location**: /specs/
- **Files**: All specification documents (*.md)
- **Protection**: Headers with `<!-- 🚫 AI_MODIFY_PROHIBITED -->`
- **Rule**: These are human-written design documents that should not be modified by AI

### Category 4: General Documentation
- **Location**: /docs/
- **Rule**: AI agents CAN modify these files for improvements and updates

### Protection Mechanisms
1. **.claudeignore file**: Lists protected files and directories
2. **File headers**: Protected files contain `<!-- 🚫 AI_MODIFY_PROHIBITED -->` header
3. **Directory structure**: Clear separation between protected and editable documentation

## Project Overview

gzh-manager-go is a comprehensive CLI tool (binary: `gz`) for managing development environments and Git repositories across multiple platforms. It provides bulk operations for cloning organizations, package management, network environment transitions, IDE settings monitoring, and development environment configuration management.

## Essential Commands

### Development Setup

```bash
make bootstrap  # Install all build dependencies - run this first
```

### Building and Running

```bash
make build      # Creates 'gz' executable
make install    # Installs to GOPATH/bin
make run        # Run with version tag
```

### Code Quality - ALWAYS RUN BEFORE COMMITTING

```bash
make fmt        # Format code with gofumpt and gci
make lint       # Run golangci-lint checks with auto-fix
make test       # Run all tests with coverage
make lint-all   # Run all linting steps (format + lint + pre-commit)
```

### Single Package Testing

```bash
# Test specific packages
go test ./cmd/git -v                    # Test git command package
go test ./cmd/synclone -v               # Test synclone package
go test ./pkg/github -v                 # Test GitHub integration
go test ./internal/git -v               # Test internal git operations

# Run specific test functions
go test ./cmd/git -run "TestExtractRepoNameFromURL" -v
go test ./cmd/git -run "TestCloneOrUpdate" -v
```

### Pre-commit Hooks Setup

```bash
make pre-commit-install    # Install pre-commit hooks (one-time setup)
make pre-commit           # Run pre-commit hooks manually
make pre-push             # Run pre-push hooks manually
make check-consistency    # Verify lint configuration consistency
```

### Testing

```bash
make test       # Run unit tests with coverage
make cover      # Show coverage with race detection
go test ./cmd/synclone -v          # Run specific package tests
go test ./cmd/ide -v               # Run IDE package tests
go test ./pkg/github -v            # Run GitHub integration tests
```

### Performance Monitoring

```bash
./scripts/simple-benchmark.sh                    # Quick performance check
./scripts/benchmark-performance.sh --baseline    # Create performance baseline
./scripts/benchmark-performance.sh --compare baseline.json  # Compare against baseline
./scripts/benchmark-performance.sh --format human          # Human-readable output
```

### Mocking Strategy

```bash
make generate-mocks    # Generate all interface mocks using gomock
make clean-mocks      # Remove all generated mock files
make regenerate-mocks # Clean and regenerate all mocks
```

## Architecture

### Command Structure

- **cmd/** - CLI commands using cobra framework
  - `root.go` - Main entry point with all command registrations
  - `git/` - **NEW**: Unified Git platform management with intelligent clone-or-update functionality
    - `repo_clone_or_update.go` - Smart repository cloning with multiple strategies (rebase, reset, clone, skip, pull, fetch)
    - Supports optional target-path (auto-extracts repo name from URL like `git clone`)
    - URL parsing for HTTPS, SSH, and various Git hosting platforms
  - `synclone/` - Multi-platform repository cloning (GitHub, GitLab, Gitea, Gogs)
  - `pm/` - Package manager updates (asdf, Homebrew, SDKMAN, npm, pip, etc.)
  - `dev-env/` - Development environment management (AWS, Docker, Kubernetes, SSH configs)
  - `net-env/` - Network environment transitions (WiFi monitoring, VPN, DNS, proxy)
  - `ide/` - JetBrains IDE settings monitoring and sync fixes
  - `repo-config/` - GitHub repository configuration management
  - `event.go` - GitHub event management and webhook server
  - `webhook.go` - GitHub webhook management

### Core Packages

- **internal/** - Private packages
  - `convert/` - Data conversion utilities
  - `git/` - **Core Git operations layer** with dependency injection pattern
    - `interfaces.go` - Defines Client, StrategyExecutor, BulkOperator, AuthManager interfaces
    - `constructors.go` - Concrete implementations with dependency injection
    - Supports multiple strategies: reset, pull, fetch, rebase operations
    - Command execution abstraction for testability
  - `testlib/` - Testing utilities and environment checkers
  - `logger/` - Logging abstraction with SimpleLogger implementation

- **pkg/** - Public packages (importable by other projects)
  - `synclone/` - Configuration loading, schema validation, URL building
  - `github/` - GitHub API integration and organization cloning
  - `gitlab/` - GitLab API integration and group cloning
  - `gitea/` - Gitea API integration and organization cloning
  - `gogs/` - Gogs API integration (planned)
  - `example/` - Example package structure

- **helpers/** - Utility functions
  - `git_helper.go` - Git repository operations and testing utilities

### Key Patterns

1. **Simplified Architecture**: Clean, direct implementation focused on CLI tool needs
   - Direct constructor pattern instead of dependency injection containers
   - `CommandExecutor` interface for shell command abstraction
   - `Logger` interface for logging abstraction
   - `Client`, `StrategyExecutor`, `BulkOperator` interfaces for Git operations
   - Concrete implementations in `constructors.go`

2. **Service-specific implementations**: Each Git platform (GitHub, GitLab, Gitea, Gogs) has dedicated packages following common interfaces

3. **Configuration-driven design**: Extensive YAML configuration support with schema validation (see `examples/` directory)

4. **Cobra CLI framework**: All commands use cobra with consistent flag patterns and help documentation

5. **Cross-platform support**: Native OS detection and platform-specific implementations (Linux, macOS, Windows)

6. **Environment variable integration**: Support for token authentication and configuration overrides

7. **Atomic operations**: Commands designed for safe execution with backup and rollback capabilities

8. **Comprehensive testing**: testify framework with mock services and environment-specific tests

9. **Standard Go tooling integration**: Uses standard `runtime/pprof` for profiling instead of custom implementations

10. **URL Parsing Strategy**: Robust URL parsing for multiple Git hosting formats (HTTPS, SSH, ssh://) in `extractRepoNameFromURL`

11. **Performance monitoring**: Automated benchmarking system with regression detection (see `scripts/` directory)

## Configuration and Schema

### Configuration File Hierarchy

1. Environment variable: `GZH_CONFIG_PATH`
2. Current directory: `./synclone.yaml` or `./synclone.yml`
3. User config: `~/.config/gzh-manager/synclone.yaml`
4. System config: `/etc/gzh-manager/synclone.yaml`

### Schema Validation

- JSON Schema: `docs/synclone-schema.json`
- YAML Schema: `docs/synclone-schema.yaml`
- Built-in validator: `gz synclone validate`

### Sample Configurations

- `examples/synclone-simple.yaml` - Minimal working example
- `examples/synclone-example.yaml` - Comprehensive with comments
- `examples/synclone.yml` - Advanced features

## Testing Guidelines

- Test files use `*_test.go` convention
- Uses testify for assertions
- Environment-specific tests check for tokens (GITHUB_TOKEN, GITLAB_TOKEN)
- Integration tests mock external services when possible
- Cross-platform testing for path handling and OS-specific features

## Important Notes

- The binary is named 'gz' not 'gzh-manager-go'
- Always run `make fmt` before committing code
- Configuration files support both CLI flags and YAML config
- Supports multiple authentication methods per service

## Command Categories

### Repository Operations

- `gz git repo clone-or-update` - **NEW**: Intelligent single repository management
  - Optional target-path (auto-extracts from URL like `git clone`)
  - Multiple strategies: rebase (default), reset, clone, skip, pull, fetch
  - Branch specification with `-b/--branch` flag
  - Examples: `gz git repo clone-or-update https://github.com/user/repo.git`
- `gz synclone` - Clone entire organizations from GitHub, GitLab, Gitea, Gogs
- `gz repo-config` - GitHub repository configuration management
- `gz event` - GitHub event management and webhook server
- `gz webhook` - GitHub webhook management

### Development Environment

- `gz dev-env` - Manage AWS, Docker, Kubernetes, SSH configurations
- `gz pm` - Update package managers (asdf, Homebrew, SDKMAN, npm, pip, etc.)
- `gz ide` - Monitor JetBrains IDE settings and fix sync issues
- `gz doctor` - Diagnose system health and configuration issues
- `gz profile` - Performance profiling using standard Go pprof (server, cpu, memory, stats)

### Network Management

- `gz net-env` - WiFi change detection, VPN/DNS/proxy management

## Repository Clone Strategies

### Single Repository (gz git repo clone-or-update)

- `rebase` (default): Rebase local changes on top of remote changes
- `reset`: Hard reset to match remote state (discards local changes)
- `clone`: Remove existing directory and perform fresh clone
- `skip`: Leave existing repository unchanged
- `pull`: Standard git pull (merge remote changes)
- `fetch`: Only fetch remote changes without updating working directory

### Bulk Operations (gz synclone)

- `reset` (default): Hard reset + pull (discards local changes)
- `pull`: Merge remote changes with local changes
- `fetch`: Update remote tracking without changing working directory

## Authentication

- Token-based authentication for private repositories
- Environment variable support (GITHUB_TOKEN, GITLAB_TOKEN, etc.)
- SSH key management and configuration

## 문서 스키마

이 프로젝트의 문서는 `~/.claude/schema.*.md` 파일들에 정의된 표준 스키마를 따릅니다.

## TODO Runner Workflow

### 🚀 TASK_RUNNER.todo 프롬프트

> **역할**
> /tasks/todo/ 디렉터리의 미완료 TODO 파일을 순차적으로 읽어 **작업 → 커밋 → 완료 파일 이동**을 자동화합니다.
> 프롬프트 사용 시 `{DIR=/tasks/todo}` 나 `{DIR=/tasks/todo/my-feature}` 처럼 디렉터리를 지정할 수 있습니다.

#### ✅ 절차

1. **다음 `[ ]` 미완료 항목 하나 선택**
   - 파일 이름 오름차순 → 항목 순서대로 탐색
   - 한 번에 1 개 작업만 처리

2. **분석 & 의존성 파악**
   - 관련 코드/문서 확인
   - 선행 조건이 누락되면 먼저 TODO 항목으로 세분화하여 같은 파일 최상단에 삽입

3. **구현 & 테스트 & 문서화**
   - 코드 / 설정 / 문서 수정
   - 핵심 로직 테스트 코드 작성

4. **포맷 & 커밋**
   - 포맷터 실행
   - 커밋 전 `[x]` 체크
   - 커밋 메시지
     ```
     feat(모듈): 작업 요약 (50자 이내)
     ```

5. **파일 이동**
   - 모든 항목이 `[x]` 되면 파일을 `/tasks/done/` 으로 이동
     → 파일명 뒤에 `__DONE_YYYYMMDD.md` 자동 추가

#### ⚠️ 유의

- 작업 불가(스펙 부재 등) → 해당 항목을 `[>]` 로 바꾸고 하단에 이유 서술
- 긴 작업은 2–4 개 하위 TODO 로 나눈 뒤 **다음 루프**에서 처리
