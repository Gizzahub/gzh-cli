# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Document Protection Rules

This project has a structured documentation system with protection rules:

### Category 1: Core Project Documents (AI Modification Prohibited)
- **Location**: Root directory
- **Files**: README.md, TECH_STACK.md, FEATURES.md, USAGE.md, CHANGELOG.md, SECURITY.md, LICENSE, CLAUDE.md
- **Protection**: Headers with `<!-- 🚫 AI_MODIFY_PROHIBITED -->`
- **Rule**: These files should NOT be modified by AI agents

### Category 2: Auto-generated API Documentation
- **Location**: /api-docs/
- **Protection**: Directory-level protection in .claudeignore
- **Rule**: No manual modifications allowed - generated by tools only

### Category 3: Core Design Specifications (AI Modification Prohibited)
- **Location**: /specs/
- **Files**: All specification documents (*.md)
- **Protection**: Headers with `<!-- 🚫 AI_MODIFY_PROHIBITED -->`
- **Rule**: These are human-written design documents that should not be modified by AI

### Category 4: General Documentation
- **Location**: /docs/
- **Rule**: AI agents CAN modify these files for improvements and updates

### Protection Mechanisms
1. **.claudeignore file**: Lists protected files and directories
2. **File headers**: Protected files contain `<!-- 🚫 AI_MODIFY_PROHIBITED -->` header
3. **Directory structure**: Clear separation between protected and editable documentation

## Project Overview

gzh-cli is a comprehensive CLI tool (binary name: `gz`) for managing development environments and Git repositories across multiple platforms. It provides unified commands for repository operations, development environment management, code quality control, and network environment transitions. The project follows a simplified CLI architecture optimized for developer productivity.

## Essential Commands

### Development Setup

```bash
make bootstrap  # Install all build dependencies - run this first
```

### Building and Running

```bash
make build      # Creates 'gz' executable
make install    # Installs to GOPATH/bin
make run        # Run with version tag
```

### Code Quality - ALWAYS RUN BEFORE COMMITTING

```bash
make fmt        # Format code with gofumpt and gci
make lint       # Run golangci-lint checks with auto-fix
make test       # Run all tests with coverage
make lint-all   # Run all linting steps (format + lint + pre-commit)
```

### Single Package Testing

```bash
# Test specific packages
go test ./cmd/git -v                    # Test git command package
go test ./cmd/synclone -v               # Test synclone package
go test ./pkg/github -v                 # Test GitHub integration
go test ./internal/git -v               # Test internal git operations

# Run specific test functions
go test ./cmd/git -run "TestExtractRepoNameFromURL" -v
go test ./cmd/git -run "TestCloneOrUpdate" -v
```

### Pre-commit Hooks Setup

```bash
make pre-commit-install    # Install pre-commit hooks (one-time setup)
make pre-commit           # Run pre-commit hooks manually
make pre-push             # Run pre-push hooks manually
make check-consistency    # Verify lint configuration consistency
```

### Testing

```bash
make test       # Run unit tests with coverage
make cover      # Show coverage with race detection
go test ./cmd/synclone -v          # Run specific package tests
go test ./cmd/ide -v               # Run IDE package tests
go test ./pkg/github -v            # Run GitHub integration tests
```

### Performance Monitoring

```bash
./scripts/simple-benchmark.sh                    # Quick performance check
./scripts/benchmark-performance.sh --baseline    # Create performance baseline
./scripts/benchmark-performance.sh --compare baseline.json  # Compare against baseline
./scripts/benchmark-performance.sh --format human          # Human-readable output
```

### Mocking Strategy

```bash
make generate-mocks    # Generate all interface mocks using gomock
make clean-mocks      # Remove all generated mock files
make regenerate-mocks # Clean and regenerate all mocks
```

## Architecture

gzh-cli follows a **simplified CLI architecture** (refactored 2025-01) that prioritizes developer productivity over abstract patterns. The architecture centers around direct constructors, interface-based abstractions, and modular command organization.

### High-Level Architecture Principles

1. **Interface-Driven Design**: Core abstractions through interfaces with concrete implementations
2. **Direct Constructor Pattern**: Avoid over-engineering with DI containers, use simple constructors
3. **Command-Centric Organization**: Each major feature is a top-level command with subcommands
4. **Configuration-First**: Unified YAML configuration system with schema validation
5. **Multi-Platform Support**: Abstracted platform providers for GitHub, GitLab, Gitea, Gogs

### Command Structure (cmd/)

```
cmd/
├── root.go              # Main CLI entry with all command registrations
├── git/                 # Unified Git platform management
│   ├── repo_clone_or_update.go  # Smart cloning with strategies
│   ├── repo_list.go     # Repository listing with output formats
│   ├── webhook.go       # Webhook management
│   └── event.go         # GitHub event processing
├── synclone/            # Multi-platform repository synchronization
├── quality/             # Multi-language code quality management
├── repo-config/         # Repository configuration management
├── dev-env/             # Development environment management
├── net-env/             # Network environment transitions
├── ide/                 # JetBrains IDE monitoring
├── pm/                  # Package manager updates
├── profile/             # Performance profiling (Go pprof)
└── doctor/              # System health diagnostics
```

### Core Architecture Layers

#### 1. Internal Layer (internal/)
**Purpose**: Private abstractions and implementations

- **`git/`** - Core Git operations with strategy pattern
  - `interfaces.go` - Client, StrategyExecutor, BulkOperator interfaces
  - `constructors.go` - Concrete implementations with dependency injection
  - `operations.go` - Git operations (clone, pull, push, reset)
- **`config/`** - Configuration management with validation
- **`logger/`** - Structured logging abstractions
- **`cli/`** - Command builder and output formatting

#### 2. Package Layer (pkg/)
**Purpose**: Public APIs and platform implementations

- **`config/`** - Unified configuration system with schema validation
- **`github/`, `gitlab/`, `gitea/`** - Platform-specific API implementations
- **`synclone/`** - Multi-platform synchronization logic
- **`git/provider/`** - Git provider abstraction layer

#### 3. Command Layer (cmd/)
**Purpose**: CLI command implementations using Cobra framework

### Key Architectural Patterns

#### Interface-Based Abstractions
```go
// Git operations abstraction
type Client interface {
    Clone(ctx context.Context, options CloneOptions) error
    Pull(ctx context.Context, options PullOptions) error
    // ...
}

// Configuration loading abstraction
type Loader interface {
    LoadConfig(ctx context.Context) (*Config, error)
    LoadConfigFromFile(ctx context.Context, filename string) (*Config, error)
}
```

#### Provider Registry Pattern
```go
// Platform providers registered at startup
providerRegistry := provider.NewRegistry()
providerRegistry.Register("github", github.NewProvider())
providerRegistry.Register("gitlab", gitlab.NewProvider())
```

#### Strategy Pattern for Git Operations
- **rebase**: Rebase local changes on remote
- **reset**: Hard reset to match remote state
- **clone**: Fresh clone (remove existing)
- **pull**: Standard git pull (merge)
- **fetch**: Update refs only

### Configuration Architecture

#### Unified Configuration System
- **Single file**: `gzh.yaml` for all commands
- **Priority system**: CLI flags > env vars > config files > defaults
- **Schema validation**: JSON Schema with detailed error messages
- **Environment variable expansion**: `${GITHUB_TOKEN}` support

#### Configuration Structure
```yaml
global:
  clone_base_dir: "$HOME/repos"
  default_strategy: reset

providers:
  github:
    token: "${GITHUB_TOKEN}"
    organizations:
      - name: "myorg"
        clone_dir: "$HOME/repos/github/myorg"
```

### Testing Architecture

#### Test Organization
- **Unit tests**: `*_test.go` files alongside source
- **Integration tests**: `test/integration/` with Docker containers
- **E2E tests**: `test/e2e/` with real CLI execution
- **Mocking**: Generated mocks with `gomock` for interfaces

#### Test Categories
```bash
make test-unit          # Fast unit tests
make test-integration   # Docker-based integration tests
make test-e2e           # End-to-end CLI tests
make test-all           # Complete test suite
```

### Data Flow Architecture

#### Typical Command Execution Flow
1. **Command parsing** (Cobra) → **Flag validation**
2. **Configuration loading** (unified config system)
3. **Provider factory** → **Interface implementation**
4. **Business logic execution** → **Result formatting**
5. **Output generation** (table/JSON/YAML/CSV)

## Configuration and Schema

### Configuration File Hierarchy

1. Environment variable: `GZH_CONFIG_PATH`
2. Current directory: `./synclone.yaml` or `./synclone.yml`
3. User config: `~/.config/gzh-manager/synclone.yaml`
4. System config: `/etc/gzh-manager/synclone.yaml`

### Schema Validation

- JSON Schema: `docs/synclone-schema.json`
- YAML Schema: `docs/synclone-schema.yaml`
- Built-in validator: `gz synclone validate`

### Sample Configurations

- `examples/synclone-simple.yaml` - Minimal working example
- `examples/synclone-example.yaml` - Comprehensive with comments
- `examples/synclone.yml` - Advanced features

## Testing Guidelines

- Test files use `*_test.go` convention
- Uses testify for assertions
- Environment-specific tests check for tokens (GITHUB_TOKEN, GITLAB_TOKEN)
- Integration tests mock external services when possible
- Cross-platform testing for path handling and OS-specific features

## Development Patterns and Guidelines

### Code Organization Principles

#### Interface-First Development
- Define interfaces in `internal/` packages before implementations
- Use `//go:generate mockgen` directives for testable interfaces
- Keep interfaces minimal and focused (Interface Segregation Principle)

#### Command Implementation Pattern
```go
// Standard command structure
func NewCommandCmd() *cobra.Command {
    var flags CommandFlags

    cmd := &cobra.Command{
        Use:   "command",
        Short: "Brief description",
        RunE: func(cmd *cobra.Command, args []string) error {
            // 1. Load configuration
            // 2. Create service with constructor
            // 3. Execute business logic
            // 4. Format and output results
        },
    }

    // Add flags consistently
    return cmd
}
```

#### Error Handling Strategy
- Use structured errors with context: `fmt.Errorf("operation failed: %w", err)`
- Define custom error types in `internal/errors/` for domain-specific errors
- Always wrap errors with meaningful context when bubbling up

#### Configuration Loading Pattern
```go
// Unified configuration approach
func loadConfig(ctx context.Context) (*config.Config, error) {
    loader := config.NewLoader()
    cfg, err := loader.LoadConfig(ctx)
    if err != nil {
        return nil, fmt.Errorf("failed to load configuration: %w", err)
    }
    return cfg, nil
}
```

### Testing Patterns

#### Mock Generation and Usage
```bash
# Generate mocks for interfaces
make generate-mocks

# Use mocks in tests
mockClient := mocks.NewMockClient(ctrl)
mockClient.EXPECT().Clone(gomock.Any(), gomock.Any()).Return(nil)
```

#### Test Categories and Naming
- **Unit tests**: `TestFunctionName` for individual functions
- **Integration tests**: `TestComponentNameIntegration` for component integration
- **E2E tests**: `TestWorkflowNameE2E` for complete workflows

#### Environment-Specific Testing
```go
// Check for required environment variables
func TestGitHubIntegration(t *testing.T) {
    if os.Getenv("GITHUB_TOKEN") == "" {
        t.Skip("GITHUB_TOKEN not set, skipping integration test")
    }
    // Test implementation
}
```

### Platform Provider Implementation

#### Adding New Git Platforms
1. Implement `provider.Interface` in `pkg/{platform}/`
2. Register provider in `provider.Registry`
3. Add platform-specific configuration to unified config schema
4. Implement API client with authentication
5. Add comprehensive tests with mocks

#### Provider Interface Requirements
```go
type Interface interface {
    GetRepositories(ctx context.Context, opts GetRepositoriesOptions) ([]Repository, error)
    CloneRepository(ctx context.Context, repo Repository, opts CloneOptions) error
    // Additional platform-specific methods
}
```

### Output Format Implementation

#### Adding New Output Formats
All commands should support multiple output formats through the `OutputFormatter`:

```go
// In command implementation
formatter := cli.NewOutputFormatter(outputFormat)
return formatter.FormatOutput(results)
```

Supported formats: `table`, `json`, `yaml`, `csv`, `html` (select commands)

### Performance Considerations

#### Concurrency Patterns
- Use worker pools for bulk operations (see `internal/workerpool/`)
- Respect API rate limits with adaptive rate limiting
- Implement graceful shutdown with context cancellation

#### Memory Management
- Stream large datasets instead of loading into memory
- Use buffered I/O for file operations
- Clean up resources with defer statements

### Security Patterns

#### Token Management
- Never log authentication tokens
- Use environment variables for sensitive data: `${GITHUB_TOKEN}`
- Validate tokens before API calls
- Implement token rotation support

#### Input Validation
- Validate all user inputs, especially URLs and file paths
- Sanitize shell command arguments
- Use parameterized queries/API calls

## Important Notes

- **Binary name**: `gz` (not `gzh-cli`)
- **Always run**: `make fmt` before committing code
- **Configuration**: Unified `gzh.yaml` supports all commands
- **Authentication**: Token-based auth for all Git platforms
- **Cross-platform**: Supports Linux, macOS, Windows
- **Modular Makefiles**: Use appropriate `make help-*` commands
- **Mock generation**: Interfaces marked with `//go:generate mockgen`
- **Schema validation**: All configs validated against JSON Schema
- **Performance monitoring**: Built-in benchmarking with `scripts/`

## Library Documentation Access with Context7

When working with this project's dependencies, use Context7 to access up-to-date documentation for better implementation guidance.

### Core Libraries Reference

#### CLI Development
- **Cobra** (`github.com/spf13/cobra`) - Command-line interface framework
  - Use for: command structure, flags, subcommands, completions
  - Context7 topics: "commands", "flags", "completions", "cobra.Command"
- **Viper** (`github.com/spf13/viper`) - Configuration management
  - Use for: environment variables, config files, settings hierarchy
  - Context7 topics: "configuration", "environment", "viper.Viper"

#### GitHub API Integration
- **go-github** (`github.com/google/go-github/v66`) - GitHub API v3/v4 client
  - Use for: repository management, webhooks, events, issues, PRs
  - Context7 topics: "repositories", "webhooks", "authentication", "client"
- **oauth2** (`golang.org/x/oauth2`) - OAuth2 authentication flows
  - Use for: token-based authentication, refresh tokens
  - Context7 topics: "token", "authentication", "config"

#### Terminal UI Framework
- **Bubble Tea** (`github.com/charmbracelet/bubbletea`) - TUI application framework
  - Use for: interactive CLI interfaces, real-time updates
  - Context7 topics: "model", "update", "view", "commands", "tea.Program"
- **Bubbles** (`github.com/charmbracelet/bubbles`) - Pre-built TUI components
  - Use for: text inputs, lists, spinners, progress bars
  - Context7 topics: "textinput", "list", "spinner", "progress"
- **Lipgloss** (`github.com/charmbracelet/lipgloss`) - Terminal styling
  - Use for: colors, borders, alignment, layouts
  - Context7 topics: "styling", "colors", "borders", "layout"

#### Testing Framework
- **Testify** (`github.com/stretchr/testify`) - Testing assertions and utilities
  - Use for: assertions, test suites, mocking helpers
  - Context7 topics: "assert", "require", "suite", "mock"
- **Testcontainers-go** (`github.com/testcontainers/testcontainers-go`) - Container-based testing
  - Use for: integration tests with real services
  - Context7 topics: "containers", "integration", "docker"
- **GoMock** (`go.uber.org/mock`) - Interface mocking framework
  - Use for: generating and using mocks in unit tests
  - Context7 topics: "mockgen", "EXPECT", "gomock.Controller"

#### AWS SDK Integration
- **AWS SDK Go v2** (`github.com/aws/aws-sdk-go-v2`) - AWS services client
  - Use for: AWS service interactions, credentials, configuration
  - Context7 topics: "config", "credentials", "services", "context"

#### Data Processing
- **YAML v3** (`gopkg.in/yaml.v3`) - YAML parsing and generation
  - Use for: configuration files, data serialization
  - Context7 topics: "marshal", "unmarshal", "yaml.Node"
- **JSON Schema** (`github.com/xeipuuv/gojsonschema`) - Schema validation
  - Use for: validating configuration and API data
  - Context7 topics: "validation", "schema", "gojsonschema.Result"
- **GJSON** (`github.com/tidwall/gjson`) - Fast JSON parsing
  - Use for: extracting values from JSON without unmarshaling
  - Context7 topics: "get", "path", "gjson.Result"

### Context7 Usage Pattern

When implementing features with these libraries:

1. **Resolve library ID first**:
   ```
   mcp__context7__resolve-library-id libraryName:"cobra"
   ```

2. **Get targeted documentation**:
   ```
   mcp__context7__get-library-docs context7CompatibleLibraryID:"/spf13/cobra" topic:"commands"
   ```

### Integration Guidelines

#### Before implementing new features:
- Look up library documentation with Context7 for current best practices
- Check for breaking changes or new features in recent versions
- Review examples and patterns specific to your use case

#### When debugging library issues:
- Use Context7 to find troubleshooting guides and common pitfalls
- Look up specific method documentation and expected behaviors
- Find community solutions and alternative approaches

#### Common Context7 queries for this project:
- Cobra: `topic:"subcommands"` for complex command hierarchies
- go-github: `topic:"pagination"` for handling large API responses
- Bubble Tea: `topic:"keyboard"` for handling user input
- Testify: `topic:"table-tests"` for parameterized testing
- AWS SDK: `topic:"retry"` for handling transient failures

## Command Categories

### Repository Operations

- `gz git repo clone-or-update` - **NEW**: Intelligent single repository management
  - Optional target-path (auto-extracts from URL like `git clone`)
  - Multiple strategies: rebase (default), reset, clone, skip, pull, fetch
  - Branch specification with `-b/--branch` flag
  - Examples: `gz git repo clone-or-update https://github.com/user/repo.git`
- `gz synclone` - Clone entire organizations from GitHub, GitLab, Gitea, Gogs
- `gz repo-config` - GitHub repository configuration management
- `gz actions-policy` - GitHub Actions policy management
- `gz quality` - Code quality checks and improvements
- `gz shell` - Shell integration and automation

### Development Environment

- `gz dev-env` - Manage AWS, Docker, Kubernetes, SSH configurations
- `gz pm` - Update package managers (asdf, Homebrew, SDKMAN, npm, pip, etc.)
- `gz ide` - Monitor JetBrains IDE settings and fix sync issues
- `gz doctor` - Diagnose system health and configuration issues
- `gz profile` - Performance profiling using standard Go pprof (server, cpu, memory, stats)

### Network Management

- `gz net-env` - WiFi change detection, VPN/DNS/proxy management

## Repository Clone Strategies

### Single Repository (gz git repo clone-or-update)

- `rebase` (default): Rebase local changes on top of remote changes
- `reset`: Hard reset to match remote state (discards local changes)
- `clone`: Remove existing directory and perform fresh clone
- `skip`: Leave existing repository unchanged
- `pull`: Standard git pull (merge remote changes)
- `fetch`: Only fetch remote changes without updating working directory

### Bulk Operations (gz synclone)

- `reset` (default): Hard reset + pull (discards local changes)
- `pull`: Merge remote changes with local changes
- `fetch`: Update remote tracking without changing working directory

## Authentication

- Token-based authentication for private repositories
- Environment variable support (GITHUB_TOKEN, GITLAB_TOKEN, etc.)
- SSH key management and configuration

## 문서 스키마

이 프로젝트의 문서는 `~/.claude/schema.*.md` 파일들에 정의된 표준 스키마를 따릅니다.

## TODO Runner Workflow

### 🚀 TASK_RUNNER.todo 프롬프트

> **역할**
> /tasks/todo/ 디렉터리의 미완료 TODO 파일을 순차적으로 읽어 **작업 → 커밋 → 완료 파일 이동**을 자동화합니다.
> 프롬프트 사용 시 `{DIR=/tasks/todo}` 나 `{DIR=/tasks/todo/my-feature}` 처럼 디렉터리를 지정할 수 있습니다.

#### ✅ 절차

1. **다음 `[ ]` 미완료 항목 하나 선택**
   - 파일 이름 오름차순 → 항목 순서대로 탐색
   - 한 번에 1 개 작업만 처리

2. **분석 & 의존성 파악**
   - 관련 코드/문서 확인
   - 선행 조건이 누락되면 먼저 TODO 항목으로 세분화하여 같은 파일 최상단에 삽입

3. **구현 & 테스트 & 문서화**
   - 코드 / 설정 / 문서 수정
   - 핵심 로직 테스트 코드 작성

4. **포맷 & 커밋**
   - 포맷터 실행
   - 커밋 전 `[x]` 체크
   - 커밋 메시지
     ```
     feat(모듈): 작업 요약 (50자 이내)
     ```

5. **파일 이동**
   - 모든 항목이 `[x]` 되면 파일을 `/tasks/done/` 으로 이동
     → 파일명 뒤에 `__DONE_YYYYMMDD.md` 자동 추가

#### ⚠️ 유의

- 작업 불가(스펙 부재 등) → 해당 항목을 `[>]` 로 바꾸고 하단에 이유 서술
- 긴 작업은 2–4 개 하위 TODO 로 나눈 뒤 **다음 루프**에서 처리
