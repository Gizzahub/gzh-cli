package sshconfig

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	bulkclone "github.com/gizzahub/gzh-manager-go/pkg/bulk-clone"
	"github.com/spf13/cobra"
)

type sshConfigGenerateOptions struct {
	configFile string
	useConfig  bool
	outputFile string
	dryRun     bool
	keyDir     string
	appendMode bool
}

func defaultSSHConfigGenerateOptions() *sshConfigGenerateOptions {
	homeDir, _ := os.UserHomeDir()

	return &sshConfigGenerateOptions{
		outputFile: filepath.Join(homeDir, ".ssh", "config"),
		keyDir:     filepath.Join(homeDir, ".ssh"),
		dryRun:     false,
		appendMode: false,
	}
}

func newSSHConfigGenerateCmd() *cobra.Command {
	o := defaultSSHConfigGenerateOptions()

	cmd := &cobra.Command{
		Use:   "generate",
		Short: "Generate SSH config entries for Git hosting services",
		Long: `Generate SSH configuration entries for GitHub, GitLab, and Gitea
based on your bulk-clone.yaml configuration.

This command creates SSH Host entries that allow you to use different SSH keys
for different organizations or services. It supports:
- Custom SSH keys per organization
- Host aliases for different services
- Automatic key path resolution
- Safe append to existing SSH config

Examples:
  # Generate SSH config from bulk-clone.yaml (dry run)
  gz ssh-config generate --config bulk-clone.yaml --dry-run
  
  # Generate and append to ~/.ssh/config
  gz ssh-config generate --config bulk-clone.yaml
  
  # Generate to custom file
  gz ssh-config generate --config bulk-clone.yaml --output ~/custom-ssh-config`,
		RunE: o.run,
	}

	cmd.Flags().StringVarP(&o.configFile, "config", "c", o.configFile, "Path to bulk-clone config file")
	cmd.Flags().BoolVar(&o.useConfig, "use-config", false, "Use config file from standard locations")
	cmd.Flags().StringVarP(&o.outputFile, "output", "o", o.outputFile, "Output SSH config file (default: ~/.ssh/config)")
	cmd.Flags().BoolVar(&o.dryRun, "dry-run", false, "Show generated config without writing to file")
	cmd.Flags().StringVar(&o.keyDir, "key-dir", o.keyDir, "Directory containing SSH keys (default: ~/.ssh)")
	cmd.Flags().BoolVar(&o.appendMode, "append", false, "Append to existing SSH config file")

	// Mark flags as mutually exclusive
	cmd.MarkFlagsMutuallyExclusive("config", "use-config")
	cmd.MarkFlagsOneRequired("config", "use-config")

	return cmd
}

func (o *sshConfigGenerateOptions) run(_ *cobra.Command, args []string) error {
	// Load configuration
	var configPath string
	if o.configFile != "" {
		configPath = o.configFile
	}

	cfg, err := bulkclone.LoadConfig(configPath)
	if err != nil {
		return fmt.Errorf("failed to load config: %w", err)
	}

	// Generate SSH config content
	sshConfig, err := o.generateSSHConfig(cfg)
	if err != nil {
		return fmt.Errorf("failed to generate SSH config: %w", err)
	}

	if o.dryRun {
		fmt.Println("# Generated SSH config (dry run):")
		fmt.Println(sshConfig)

		return nil
	}

	// Write to file
	err = o.writeSSHConfig(sshConfig)
	if err != nil {
		return fmt.Errorf("failed to write SSH config: %w", err)
	}

	fmt.Printf("âœ“ SSH config generated successfully: %s\n", o.outputFile)

	return nil
}

func (o *sshConfigGenerateOptions) generateSSHConfig(cfg *bulkclone.BulkCloneConfig) (string, error) {
	var configLines []string

	// Add header comment
	configLines = append(configLines, "# Generated by gzh-manager ssh-config")
	configLines = append(configLines, "# Auto-generated SSH configuration for Git hosting services")
	configLines = append(configLines, "")

	// Keep track of hosts we've already configured to avoid duplicates
	configuredHosts := make(map[string]bool)

	// Generate config for each repository root
	for _, repoRoot := range cfg.RepoRoots {
		if repoRoot.Protocol != "ssh" {
			continue // Skip non-SSH configurations
		}

		hostConfig, err := o.generateHostConfig(repoRoot.Provider, repoRoot.OrgName, configuredHosts)
		if err != nil {
			return "", err
		}

		if hostConfig != "" {
			configLines = append(configLines, hostConfig)
			configLines = append(configLines, "")
		}
	}

	// Generate config for default configurations if they use SSH
	if cfg.Default.Protocol == "ssh" {
		if cfg.Default.Github.OrgName != "" {
			hostConfig, err := o.generateHostConfig("github", cfg.Default.Github.OrgName, configuredHosts)
			if err != nil {
				return "", err
			}

			if hostConfig != "" {
				configLines = append(configLines, hostConfig)
				configLines = append(configLines, "")
			}
		}

		if cfg.Default.Gitlab.GroupName != "" {
			hostConfig, err := o.generateHostConfig("gitlab", cfg.Default.Gitlab.GroupName, configuredHosts)
			if err != nil {
				return "", err
			}

			if hostConfig != "" {
				configLines = append(configLines, hostConfig)
				configLines = append(configLines, "")
			}
		}
	}

	if len(configLines) <= 3 { // Only header comments
		return "# No SSH configurations found in the provided config file\n", nil
	}

	return strings.Join(configLines, "\n"), nil
}

func (o *sshConfigGenerateOptions) generateHostConfig(provider, orgName string, configuredHosts map[string]bool) (string, error) {
	var hostname, hostAlias string

	switch provider {
	case "github":
		hostname = "github.com"
		hostAlias = fmt.Sprintf("github-%s", orgName)
	case "gitlab":
		hostname = "gitlab.com"
		hostAlias = fmt.Sprintf("gitlab-%s", orgName)
	case "gitea":
		hostname = "gitea.com" // Default, can be customized
		hostAlias = fmt.Sprintf("gitea-%s", orgName)
	default:
		return "", fmt.Errorf("unsupported provider: %s", provider)
	}

	// Check if we've already configured this host
	if configuredHosts[hostAlias] {
		return "", nil // Skip duplicate
	}

	configuredHosts[hostAlias] = true

	// Generate SSH key path
	keyPath := o.getSSHKeyPath(provider, orgName)

	var configLines []string

	configLines = append(configLines, fmt.Sprintf("# %s organization: %s", strings.ToUpper(provider[:1])+provider[1:], orgName))
	configLines = append(configLines, fmt.Sprintf("Host %s", hostAlias))
	configLines = append(configLines, fmt.Sprintf("    HostName %s", hostname))
	configLines = append(configLines, "    User git")
	configLines = append(configLines, fmt.Sprintf("    IdentityFile %s", keyPath))
	configLines = append(configLines, "    IdentitiesOnly yes")

	return strings.Join(configLines, "\n"), nil
}

func (o *sshConfigGenerateOptions) getSSHKeyPath(provider, orgName string) string {
	// Try different key naming conventions
	possibleKeys := []string{
		fmt.Sprintf("%s_%s", provider, orgName),
		fmt.Sprintf("%s-%s", provider, orgName),
		fmt.Sprintf("id_%s_%s", provider, orgName),
		fmt.Sprintf("id_rsa_%s_%s", provider, orgName),
		provider,
		fmt.Sprintf("id_%s", provider),
		"id_rsa", // Fallback to default
	}

	for _, keyName := range possibleKeys {
		keyPath := filepath.Join(o.keyDir, keyName)
		if _, err := os.Stat(keyPath); err == nil {
			return keyPath
		}

		// Also check with .pub extension removed and private key
		if strings.HasSuffix(keyName, ".pub") {
			privateKeyPath := filepath.Join(o.keyDir, strings.TrimSuffix(keyName, ".pub"))
			if _, err := os.Stat(privateKeyPath); err == nil {
				return privateKeyPath
			}
		}
	}

	// If no existing key found, suggest a conventional path
	return filepath.Join(o.keyDir, fmt.Sprintf("id_rsa_%s_%s", provider, orgName))
}

func (o *sshConfigGenerateOptions) writeSSHConfig(content string) error {
	// Ensure SSH directory exists
	sshDir := filepath.Dir(o.outputFile)
	if err := os.MkdirAll(sshDir, 0o700); err != nil {
		return fmt.Errorf("failed to create SSH directory: %w", err)
	}

	// Check if file exists and append mode is requested
	var existingContent string

	if o.appendMode {
		if data, err := os.ReadFile(o.outputFile); err == nil {
			existingContent = string(data)
			if !strings.HasSuffix(existingContent, "\n") {
				existingContent += "\n"
			}
		}
	}

	// Combine existing content with new content
	finalContent := existingContent + content

	// Write to file with appropriate permissions
	err := os.WriteFile(o.outputFile, []byte(finalContent), 0o600)
	if err != nil {
		return fmt.Errorf("failed to write SSH config file: %w", err)
	}

	return nil
}
