package sshconfig

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestSSHConfigGenerate(t *testing.T) {
	tempDir := t.TempDir()

	// Create a test config file
	configContent := `version: "0.1"
default:
  protocol: ssh
  github:
    root_path: "%s/github-repos"
    org_name: "default-org"
repo_roots:
  - root_path: "%s/work/company"
    provider: "github"
    protocol: "ssh"
    org_name: "mycompany"
  - root_path: "%s/opensource"
    provider: "github"
    protocol: "https"
    org_name: "kubernetes"
  - root_path: "%s/gitlab-projects"
    provider: "gitlab"
    protocol: "ssh"
    org_name: "mygroup"
`
	configPath := filepath.Join(tempDir, "test-config.yaml")
	formattedConfig := strings.ReplaceAll(configContent, "%s", tempDir)
	err := os.WriteFile(configPath, []byte(formattedConfig), 0o644)
	require.NoError(t, err)

	t.Run("dry run generates correct SSH config", func(t *testing.T) {
		opts := &sshConfigGenerateOptions{
			configFile: configPath,
			dryRun:     true,
			keyDir:     filepath.Join(tempDir, ".ssh"),
		}

		err := opts.run(nil, []string{})
		assert.NoError(t, err)
	})

	t.Run("generate SSH config to file", func(t *testing.T) {
		sshDir := filepath.Join(tempDir, ".ssh")
		outputFile := filepath.Join(sshDir, "config")

		opts := &sshConfigGenerateOptions{
			configFile: configPath,
			outputFile: outputFile,
			keyDir:     sshDir,
			dryRun:     false,
		}

		err := opts.run(nil, []string{})
		assert.NoError(t, err)

		// Check that SSH config file was created
		assert.FileExists(t, outputFile)

		// Read and verify content
		content, err := os.ReadFile(outputFile)
		require.NoError(t, err)

		configText := string(content)
		assert.Contains(t, configText, "# Generated by gzh-manager ssh-config")
		assert.Contains(t, configText, "Host github-mycompany")
		assert.Contains(t, configText, "HostName github.com")
		assert.Contains(t, configText, "Host gitlab-mygroup")
		assert.Contains(t, configText, "HostName gitlab.com")

		// Should not contain HTTPS configurations
		assert.NotContains(t, configText, "Host github-kubernetes")

		// Should contain default SSH config
		assert.Contains(t, configText, "Host github-default-org")
	})

	t.Run("append mode preserves existing content", func(t *testing.T) {
		sshDir := filepath.Join(tempDir, ".ssh-append")
		outputFile := filepath.Join(sshDir, "config")

		// Create existing SSH config
		err := os.MkdirAll(sshDir, 0o700)
		require.NoError(t, err)

		existingContent := "# Existing SSH config\nHost existing\n    HostName example.com\n"
		err = os.WriteFile(outputFile, []byte(existingContent), 0o600)
		require.NoError(t, err)

		opts := &sshConfigGenerateOptions{
			configFile: configPath,
			outputFile: outputFile,
			keyDir:     sshDir,
			appendMode: true,
		}

		err = opts.run(nil, []string{})
		assert.NoError(t, err)

		// Read and verify content
		content, err := os.ReadFile(outputFile)
		require.NoError(t, err)

		configText := string(content)
		assert.Contains(t, configText, "# Existing SSH config")
		assert.Contains(t, configText, "Host existing")
		assert.Contains(t, configText, "# Generated by gzh-manager ssh-config")
		assert.Contains(t, configText, "Host github-mycompany")
	})
}

func TestSSHConfigValidate(t *testing.T) {
	tempDir := t.TempDir()

	// Create a test config file
	configContent := `version: "0.1"
default:
  protocol: ssh
repo_roots:
  - root_path: "%s/work/company"
    provider: "github"
    protocol: "ssh"
    org_name: "mycompany"
`
	configPath := filepath.Join(tempDir, "test-config.yaml")
	formattedConfig := strings.ReplaceAll(configContent, "%s", tempDir)
	err := os.WriteFile(configPath, []byte(formattedConfig), 0o644)
	require.NoError(t, err)

	t.Run("validation fails when SSH config missing", func(t *testing.T) {
		sshConfigPath := filepath.Join(tempDir, "nonexistent-ssh-config")

		opts := &sshConfigValidateOptions{
			configFile: configPath,
			sshConfig:  sshConfigPath,
			keyDir:     filepath.Join(tempDir, ".ssh"),
		}

		err := opts.run(nil, []string{})
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "SSH configuration validation failed")
	})

	t.Run("validation passes with proper SSH config", func(t *testing.T) {
		sshDir := filepath.Join(tempDir, ".ssh-valid")
		sshConfigPath := filepath.Join(sshDir, "config")

		// Create SSH directory and config
		err := os.MkdirAll(sshDir, 0o700)
		require.NoError(t, err)

		sshConfigContent := `# SSH config for validation test
Host github-mycompany
    HostName github.com
    User git
    IdentityFile %s/id_rsa_github_mycompany
    IdentitiesOnly yes
`
		sshConfig := strings.ReplaceAll(sshConfigContent, "%s", sshDir)
		err = os.WriteFile(sshConfigPath, []byte(sshConfig), 0o600)
		require.NoError(t, err)

		// Create SSH key files
		keyPath := filepath.Join(sshDir, "id_rsa_github_mycompany")
		pubKeyPath := keyPath + ".pub"

		err = os.WriteFile(keyPath, []byte("fake-private-key"), 0o600)
		require.NoError(t, err)

		err = os.WriteFile(pubKeyPath, []byte("fake-public-key"), 0o644)
		require.NoError(t, err)

		opts := &sshConfigValidateOptions{
			configFile: configPath,
			sshConfig:  sshConfigPath,
			keyDir:     sshDir,
		}

		err = opts.run(nil, []string{})
		assert.NoError(t, err)
	})

	t.Run("validation detects permission issues", func(t *testing.T) {
		sshDir := filepath.Join(tempDir, ".ssh-perms")
		sshConfigPath := filepath.Join(sshDir, "config")

		// Create SSH directory with wrong permissions
		err := os.MkdirAll(sshDir, 0o755) // Wrong permissions
		require.NoError(t, err)

		sshConfigContent := `Host github-mycompany
    HostName github.com
    User git
    IdentityFile %s/id_rsa_github_mycompany
`
		sshConfig := strings.ReplaceAll(sshConfigContent, "%s", sshDir)
		err = os.WriteFile(sshConfigPath, []byte(sshConfig), 0o644) // Wrong permissions
		require.NoError(t, err)

		// Create SSH key with wrong permissions
		keyPath := filepath.Join(sshDir, "id_rsa_github_mycompany")
		err = os.WriteFile(keyPath, []byte("fake-private-key"), 0o644) // Wrong permissions
		require.NoError(t, err)

		opts := &sshConfigValidateOptions{
			configFile: configPath,
			sshConfig:  sshConfigPath,
			keyDir:     sshDir,
		}

		err = opts.run(nil, []string{})
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "SSH configuration validation failed")
	})
}

func TestSSHKeyPathGeneration(t *testing.T) {
	tempDir := t.TempDir()

	opts := &sshConfigGenerateOptions{
		keyDir: tempDir,
	}

	t.Run("finds existing SSH key", func(t *testing.T) {
		keyPath := filepath.Join(tempDir, "github_mycompany")
		err := os.WriteFile(keyPath, []byte("fake-key"), 0o600)
		require.NoError(t, err)

		result := opts.getSSHKeyPath("github", "mycompany")
		assert.Equal(t, keyPath, result)
	})

	t.Run("suggests conventional path when no key exists", func(t *testing.T) {
		result := opts.getSSHKeyPath("gitlab", "mygroup")
		expected := filepath.Join(tempDir, "id_rsa_gitlab_mygroup")
		assert.Equal(t, expected, result)
	})

	t.Run("prefers provider-specific keys", func(t *testing.T) {
		// Create a generic key
		genericKeyPath := filepath.Join(tempDir, "id_rsa")
		err := os.WriteFile(genericKeyPath, []byte("generic-key"), 0o600)
		require.NoError(t, err)

		// Create a provider-specific key
		specificKeyPath := filepath.Join(tempDir, "gitea_myorg")
		err = os.WriteFile(specificKeyPath, []byte("specific-key"), 0o600)
		require.NoError(t, err)

		result := opts.getSSHKeyPath("gitea", "myorg")
		assert.Equal(t, specificKeyPath, result)
	})
}

func TestSSHConfigCommand(t *testing.T) {
	t.Run("command creation", func(t *testing.T) {
		cmd := NewSSHConfigCmd()
		assert.NotNil(t, cmd)
		assert.Equal(t, "ssh-config", cmd.Use)
		assert.Contains(t, cmd.Short, "SSH configuration management")

		// Check that it has subcommands
		subcommands := cmd.Commands()
		subcommandNames := make([]string, len(subcommands))
		for i, subcmd := range subcommands {
			subcommandNames[i] = subcmd.Use
		}

		assert.Contains(t, subcommandNames, "generate")
		assert.Contains(t, subcommandNames, "validate")
	})

	t.Run("generate command has correct flags", func(t *testing.T) {
		cmd := NewSSHConfigCmd()
		generateCmd := cmd.Commands()[0] // generate should be first

		configFlag := generateCmd.Flags().Lookup("config")
		assert.NotNil(t, configFlag)
		assert.Equal(t, "c", configFlag.Shorthand)

		useConfigFlag := generateCmd.Flags().Lookup("use-config")
		assert.NotNil(t, useConfigFlag)

		outputFlag := generateCmd.Flags().Lookup("output")
		assert.NotNil(t, outputFlag)
		assert.Equal(t, "o", outputFlag.Shorthand)

		dryRunFlag := generateCmd.Flags().Lookup("dry-run")
		assert.NotNil(t, dryRunFlag)

		appendFlag := generateCmd.Flags().Lookup("append")
		assert.NotNil(t, appendFlag)
	})

	t.Run("validate command has correct flags", func(t *testing.T) {
		cmd := NewSSHConfigCmd()
		validateCmd := cmd.Commands()[1] // validate should be second

		configFlag := validateCmd.Flags().Lookup("config")
		assert.NotNil(t, configFlag)
		assert.Equal(t, "c", configFlag.Shorthand)

		sshConfigFlag := validateCmd.Flags().Lookup("ssh-config")
		assert.NotNil(t, sshConfigFlag)

		keyDirFlag := validateCmd.Flags().Lookup("key-dir")
		assert.NotNil(t, keyDirFlag)
	})
}
